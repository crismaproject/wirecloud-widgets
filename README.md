# Wirecloud Widgets

This repository contains (more or less) general purpose widgets that can be used with
[FI-Ware](http://www.fi-ware.eu/)'s Mashup platform [Wirecloud](http://conwet.fi.upm.es/wirecloud/).
Ideally, every folder here contains a widget that should work on its own and expose its functionality via a set of
JavaScript functions. Primarily, they are intended to be used in the context of Wirecloud, so their usefulness outside
of the Mashup platform could be limited.

You can find a working and up-to-date Wirecloud testbed here, courtesy of [FI-Ware](http://www.fi-ware.org/):
[mashup.lab.fi-ware.org](https://mashup.lab.fi-ware.org).

Also note that these components are currently under **early and active development** — they might or might not work yet.

## Content

In the following sections, each listed item is either prefixed with `(o)` or `(w)`. This indicates if a gadget is either
an **o**perator or a **w**idget.

### Primary widgets and operators

* (w) **./chart/** — a simple widget that uses [jQuery](http://jquery.com/) and [d3](http://d3js.org/) to render bar
      charts.
* (w) **./indicators/** — this widget displays indicators from the OOI-WSR.
* (o) **./merger/** — a simple operator that merges two JSON arrays into one (useful for combining data sources).
* (w) **./ooi_command/** — widget to issue commands to OOIs.
* (w) **./ooi_gis_map/** — a map widget using [OpenLayers](http://www.openlayers.org/) and
      [OpenStreetMap](http://www.openstreetmap.org/) to display a map with WFS data
* (w) **./ooi_table/** — OOI table (with synchronized OOI selection mechanic).
* (w) **./simulation_picker/** — displays and picks available simulations from the OOI-WSR.
* (w) **./worldstate_picker/** — Widget that allows the user to pick a world state from the OOI-WSR.
* (w) **./worldstate_saver/** — Widget that saves a world state to an OOI-WSR instance.

### Development-only widgets and operators

The following gadgets are only used for development and debugging purposes and serve no practical use in a
production environment.

* (w) **./debug_hide_ui/** — a simple debugging widget that hides most of the UI elements not belonging to the
      actual mashup application.
* (w) **./debug_listener/** — a simple debugging widget that shows incoming events.
* (w) **./debug_pusher/** — a simple debugging widget that pushes arbitrary data to endpoints.

### Misc.

* (w) **./empty/** — contains an absolutely empty widget that can be used as a starting template.

### Documentations

Documentation for endpoints can be found in each of the widgets' respective subdirectory, in a file aptly
named `ENDPOINTS.md`. These files are automatically generated from Wirecloud metadata in each `config.xml`.
To (re-)generate these files on your own, you can use the `rake doc` rake task.

## Building

There are two ways to build these widgets:

* **If you have ruby/rake:** use `rake all`. It will build any widgets in subdirectories containing a `.bundle` file.
    There are also rake tasks to bundle widgets individually; for instance, to build the *openlayers* directory, use
    `rake bundle[openlayers]`. For this to work, you need to have the following gems installed (`gem install …`):
    * `rubyzip`,
    * `nokogiri`,
    * `rest_client`,
    * `json`

    You might be able to work around these dependencies if you fiddle with the `Rakefile`.

* **Build it manually:** use any compression tool to create ZIP files for each of the widgets you are interested in so
    that the *config.xml* file is in the root directory of the archive. If you want to, exclude Markdown files.
    By convention, you should then change the extension from `.zip` to `.wgt`.

    If you want to contribute other ways of building/bundling widgets (or documentation), feel free to do so and send me
    a push request.

## Branches

* **master** — recommended latest version (currently pointing at v0.6)
* **v0.5** — currently somewhat stable version; receives maintenance updates where applicable.
* **v0.6** — this is some sort of staging area for the *next* version and most commits are likely to not work
    completely.

## Rake tasks

If you happen to have Ruby/Rake installed, you can automate a lot of actions. Here's a handy list of tasks defined
in the Rakefile, in order of importance/usefulness:

* **bundle[*this*]**: packs subfolder `this` into a ready-to-upload Wirecloud widget file as `this.wgt`
    (basically it ZIPs the entire folder sans Markdown files).
* **all**: Performs the **bundle** task for each subfolder. It also runs **cleanup**, **update** and **doc** before
    that.
* **cleanup**: Deletes any files that look like they were automatically generated by **bundle** or **doc** (so,
    basically all `.wgt` files in the root folder as well as `documentation.htm` files in subfolders (non-recursive)).
* **update**: Updates all `wsrapi.js` files in subfolders (see section WSR-API).
* **doc**: Automagically creates human-readable mini-documentation for each widget and operator using the gadgets'
    `config.xml` file using one of the XSLT stylesheets (widget.xslt, widget-rdf.xslt).

Note that the Rakefile requires `rubyzip` and `nokogiri` for some operations. These two gems should be present, or
your Rakefile might not work at all.

## WSR-API

Versions 0.6 and upwards are beginning to incorporate a shared World State Repository API (WSR-API). Its implementation
allows for streamlined handling of RESTful operations with the external World State Repository, including (but not
limited to) CRUD operations of entities, world states, simulation data, etc. To use it, one only needs to load
`wsrapi.js` and create a new instance of the `WorldStateRepository` JavaScript class. Note that this API implementation
relies on jQuery for AJAX operations and deferred functionalities; it is necessary to load jQuery 2.x first.

A full list of operations is provided in `wsrapi-documentation.htm`. This file automatically inspects `wsrapi.js` and
lists all instance methods discovered through reflection of the class.

**Important:**
If a widget or operator uses the WSR-API, it should exist as *your_widget_name/js/wsrapi.js*. This has the benefit that
whenever *wsrapi.js* in the root directory changes, a rake task will automatically update all
*your_widget_name/js/wsrapi.js* file instances it can find by replacing it with the one in the root directory. Note that
if you have done *any* changes to your gadget's file, it *will* be overwritten without hestitation by rake.

## Wirecloud API mockup

This repository includes a very simplified, stripped-down mockup for Wirecloud's public API in `wirecloud_dummy.js`.
It can be used to test some widgets if the mockup's reduced functionality is sufficient. Please refer to the
JavaScript file to see what works and what doesn't.

Note: if your widgets absolutely *require* some preferences to be set to work, you have two options:

1. if it doesn't matter when they are set, test if you are currently using the "live" Wirecloud API or just the mockup.
    The mockup has a property `MashupPlatform.dummy` that is `true`; you can then set preferences to your heart's
    content using `MashupPlatform.prefs.set(key, value)`.
2. if your preferences need to be loaded ASAP for some reason and option (1) is just a little bit too late, you
    can (as a last resort measure!) try to set your preferences in HTML's `sessionStorage` like so:

    `sessionStorage.setItem('preferences', JSON.stringify({ pref1: 'value1', pref2: 'value2' }))`

    The mockup uses HTML's sessionStorage to store preferences when the DOM unloads and restores them once the mockup is
    loaded again. Note that your browser might not have a sessionStorage (but it's very likely). To learn more about
    HTML's sessionStorage, you can read [this specification](http://www.w3.org/TR/webstorage/) and the current
    [implementation/support status](http://caniuse.com/#search=sessionstorage).

Note that undocumented (ie. non-public) methods of Wirecloud's API are not mocked; for instance,
`MashupPlatform.wiring.getReachableEndpoints(…)` is not defined by this mockup (but exists in Wirecloud's "live"
API and is, for instance, used by the `debug_pusher` widget to determine if/what gadgets are connected to it.

## Contact

Most widgets are currently maintained by Manuel Warum from the Austrian Institute of Technology (AIT). If you need
assistance, feel free to drop me a line: manuel *(dot)* warum *(dot)* fl *(at)* ait *(dot)* ac *(dot)* at, or
[MrManny](https://github.com/MrManny) on github.
